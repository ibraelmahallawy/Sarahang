/*
 * Copyright (C) 2021, Alashov Berkeli
 * All rights reserved.
 */
package com.sarahang.playback.ui.audio

import android.graphics.Bitmap
import androidx.annotation.ColorInt
import androidx.annotation.FloatRange
import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.tween
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.contentColorFor
import androidx.compose.runtime.Composable
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.State
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.compositeOver
import androidx.compose.ui.graphics.toArgb
import androidx.core.graphics.ColorUtils
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.palette.graphics.Palette
import com.sarahang.playback.core.PlaybackConnection
import com.sarahang.playback.core.artwork
import com.sarahang.playback.core.models.LocalPlaybackConnection
import com.sarahang.playback.ui.theme.PlayerTheme
import kotlinx.coroutines.delay
import android.graphics.Color as AColor

val ADAPTIVE_COLOR_ANIMATION: AnimationSpec<Color> = tween(easing = FastOutSlowInEasing)

@Immutable
data class AdaptiveColorResult(val primary: Color, val onPrimary: Color, val gradient: Brush)

fun Color.toAdaptiveColor(
    isDarkColors: Boolean,
    gradientEndColor: Color = if (isDarkColors) Color.White else Color.Black,
) = AdaptiveColorResult(
    primary = this,
    onPrimary = this.contentColor(),
    gradient = backgroundGradient(this, gradientEndColor, isDarkColors)
)

private val adaptiveColorCache = mutableMapOf<String, Color>()

@Composable
fun adaptiveColor(
    image: Bitmap? = null,
    imageSource: Any? = image,
    fallback: Color = MaterialTheme.colorScheme.secondary.contrastComposite(),
    initial: Color = fallback,
    animationSpec: AnimationSpec<Color> = ADAPTIVE_COLOR_ANIMATION,
    gradientEndColor: Color = if (PlayerTheme.isLightTheme) Color.White else Color.Black,
    isDarkColors: Boolean = isSystemInDarkTheme()
): State<AdaptiveColorResult> {
    val imageHash = imageSource.hashCode().toString()
    val initialAccent = adaptiveColorCache.getOrElse(imageHash) { initial }

    var accent by remember { mutableStateOf(initialAccent) }
    val accentAnimated by animateColorAsState(accent, animationSpec)

    var paletteGenerated by remember { mutableStateOf(false) }
    var delayInitialFallback by remember { mutableStateOf(imageSource != null) }

    LaunchedEffect(image, fallback, isDarkColors) {
        if (image != null && imageSource != null) {
            accent = adaptiveColorCache.getOrPut(imageHash) {
                val palette = Palette.from(image).generate()
                getAccentColor(isDarkColors, fallback.toArgb(), palette).toColors()
            }
            paletteGenerated = true
        }
    }

    // when fallback color changes
    // reset initial accent color if palette hasn't been generated yet
    LaunchedEffect(fallback) {
        if (delayInitialFallback)
            delay(1000)
        if (!paletteGenerated) {
            accent = fallback
            delayInitialFallback = false
        }
    }

    return derivedStateOf {
        accentAnimated.toAdaptiveColor(isDarkColors, gradientEndColor)
    }
}

fun backgroundGradient(
    accent: Color,
    endColor: Color,
    isDark: Boolean,
): Brush {
    val first = gradientShift(isDark, accent.toArgb(), 0.4f, 70)
    val second = gradientShift(isDark, accent.toArgb(), 0.26f, 33)
    val third = gradientShift(isDark, accent.toArgb(), 0.13f, 12)

    return Brush.verticalGradient(listOf(first, second, third, endColor))
}

fun getAccentColor(isDark: Boolean, default: Int, palette: Palette): Int {
    when (isDark) {
        true -> {
            val darkMutedColor = palette.getDarkMutedColor(default)
            val lightMutedColor = palette.getLightMutedColor(darkMutedColor)
            val darkVibrant = palette.getDarkVibrantColor(lightMutedColor)
            val lightVibrant = palette.getLightVibrantColor(darkVibrant)
            val mutedColor = palette.getMutedColor(lightVibrant)
            return palette.getVibrantColor(mutedColor)
        }

        false -> {
            val lightMutedColor = palette.getLightMutedColor(default)
            val lightVibrant = palette.getLightVibrantColor(lightMutedColor)
            val mutedColor = palette.getMutedColor(lightVibrant)
            val darkMutedColor = palette.getDarkMutedColor(mutedColor)
            val vibrant = palette.getVibrantColor(darkMutedColor)
            return palette.getDarkVibrantColor(vibrant)
        }
    }
}

private fun gradientShift(isDarkMode: Boolean, color: Int, shift: Float, alpha: Int): Color {
    return Color(
        if (isDarkMode) shiftColor(color, shift) else ColorUtils.setAlphaComponent(
            shiftColor(color, 2f),
            alpha
        )
    )
}

fun Color.contentColor() = getContrastColor(toArgb()).toColors()

fun getContrastColor(@ColorInt color: Int): Int {
    // Counting the perceptive luminance - human eye favors green color...
    val a: Double =
        1 - (0.299 * AColor.red(color) + 0.587 * AColor.green(color) + 0.114 * AColor.blue(color)) / 255
    return if (a < 0.5) AColor.BLACK else AColor.WHITE
}

fun shiftColor(@ColorInt color: Int, @FloatRange(from = 0.0, to = 2.0) by: Float): Int {
    return if (by == 1.0f) {
        color
    } else {
        val alpha = AColor.alpha(color)
        val hsv = FloatArray(3)
        AColor.colorToHSV(color, hsv)
        hsv[2] *= by
        (alpha shl 24) + (16777215 and AColor.HSVToColor(hsv))
    }
}

fun Int.toColors() = Color(this)

@Composable
fun Color.contrastComposite(alpha: Float = 0.1f) =
    contentColorFor(this).copy(alpha = alpha).compositeOver(this)

@Composable
fun nowPlayingArtworkAdaptiveColor(
    playbackConnection: PlaybackConnection = LocalPlaybackConnection.current
): State<AdaptiveColorResult> {
    val nowPlaying by playbackConnection.nowPlaying.collectAsStateWithLifecycle()
    return adaptiveColor(nowPlaying.artwork, initial = MaterialTheme.colorScheme.background)
}

@Composable
fun materialYouAdaptiveColor(): State<AdaptiveColorResult> {
    val primary = MaterialTheme.colorScheme.primary
    val onPrimary = MaterialTheme.colorScheme.onPrimary

    val adaptiveColor = remember {
        mutableStateOf(
            AdaptiveColorResult(
                primary,
                onPrimary,
                Brush.verticalGradient(listOf(primary, Color.Transparent))
            )
        )
    }

    return adaptiveColor
}
